
Opcode	Type	C Pseudo	Explanation
0NNN	Call		Calls machine code routine (RCA 1802 for COSMAC VIP) at address NNN. Not necessary for most ROMs.[13]
00E0	Display	disp_clear()	Clears the screen.[13]
00EE	Flow	return;	Returns from a subroutine.[13]
1NNN	Flow	goto NNN;	Jumps to address NNN.[13]
2NNN	Flow	*(0xNNN)()	Calls subroutine at NNN.[13]
3XNN	Cond	if (Vx == NN)	Skips the next instruction if VX equals NN (usually the next instruction is a jump to skip a code block).[13]
4XNN	Cond	if (Vx != NN)	Skips the next instruction if VX does not equal NN (usually the next instruction is a jump to skip a code block).[13]
5XY0	Cond	if (Vx == Vy)	Skips the next instruction if VX equals VY (usually the next instruction is a jump to skip a code block).[13]
6XNN	Const	Vx = NN	Sets VX to NN.[13]
7XNN	Const	Vx += NN	Adds NN to VX (carry flag is not changed).[13]
8XY0	Assig	Vx = Vy	Sets VX to the value of VY.[13]
8XY1	BitOp	Vx |= Vy	Sets VX to VX or VY. (bitwise OR operation).[13]
8XY2	BitOp	Vx &= Vy	Sets VX to VX and VY. (bitwise AND operation).[13]
8XY3[a]	BitOp	Vx ^= Vy	Sets VX to VX xor VY.[13]
8XY4	Math	Vx += Vy	Adds VY to VX. VF is set to 1 when there's an overflow, and to 0 when there is not.[13]
8XY5	Math	Vx -= Vy	VY is subtracted from VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VX >= VY and 0 if not).[13]
8XY6[a]	BitOp	Vx >>= 1	Stores the least significant bit of VX in VF and then shifts VX to the right by 1.[b][13]
8XY7[a]	Math	Vx = Vy - Vx	Sets VX to VY minus VX. VF is set to 0 when there's an underflow, and 1 when there is not. (i.e. VF set to 1 if VY >= VX).[13]
8XYE[a]	BitOp	Vx <<= 1	Stores the most significant bit of VX in VF and then shifts VX to the left by 1.[b][13]
9XY0	Cond	if (Vx != Vy)	Skips the next instruction if VX does not equal VY. (Usually the next instruction is a jump to skip a code block).[13]
ANNN	MEM	I = NNN	Sets I to the address NNN.[13]
BNNN	Flow	PC = V0 + NNN	Jumps to the address NNN plus V0.[13]
CXNN	Rand	Vx = rand() & NN	Sets VX to the result of a bitwise and operation on a random number (Typically: 0 to 255) and NN.[13]
DXYN	Display	draw(Vx, Vy, N)	Draws a sprite at coordinate (VX, VY) that has a width of 8 pixels and a height of N pixels. Each row of 8 pixels is read as bit-coded starting from memory location I; I value does not change after the execution of this instruction. As described above, VF is set to 1 if any screen pixels are flipped from set to unset when the sprite is drawn, and to 0 if that does not happen.[13]
EX9E	KeyOp	if (key() == Vx)	Skips the next instruction if the key stored in VX is pressed (usually the next instruction is a jump to skip a code block).[13]
EXA1	KeyOp	if (key() != Vx)	Skips the next instruction if the key stored in VX is not pressed (usually the next instruction is a jump to skip a code block).[13]
FX07	Timer	Vx = get_delay()	Sets VX to the value of the delay timer.[13]
FX0A	KeyOp	Vx = get_key()	A key press is awaited, and then stored in VX (blocking operation, all instruction halted until next key event).[13]
FX15	Timer	delay_timer(Vx)	Sets the delay timer to VX.[13]
FX18	Sound	sound_timer(Vx)	Sets the sound timer to VX.[13]
FX1E	MEM	I += Vx	Adds VX to I. VF is not affected.[c][13]
FX29	MEM	I = sprite_addr[Vx]	Sets I to the location of the sprite for the character in VX. Characters 0-F (in hexadecimal) are represented by a 4x5 font.[13]
FX33	BCD	
set_BCD(Vx)
*(I+0) = BCD(3);
*(I+1) = BCD(2);
*(I+2) = BCD(1);
Stores the binary-coded decimal representation of VX, with the hundreds digit in memory at location in I, the tens digit at location I+1, and the ones digit at location I+2.[13]
FX55	MEM	reg_dump(Vx, &I)	Stores from V0 to VX (including VX) in memory, starting at address I. The offset from I is increased by 1 for each value written, but I itself is left unmodified.[d][13]
FX65	MEM	reg_load(Vx, &I)	Fills from V0 to VX (including VX) with values from memory, starting at address I. The offset from I is increased by 1 for each value read, but I itself is left unmodified.[d][13]

Address - 0 (partial) & 1 & 2 & A & B
One Register + Value - 3 & 4 & 6 & 7 & C
One Register + Two Discriminators - E & F
Two Registers + Discriminator - 5 & 8 & 9
Two Register + Value (4-bit) - D